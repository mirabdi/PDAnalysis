<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PDAnalysis.pdb_parser API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PDAnalysis.pdb_parser</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import defaultdict
from pathlib import Path

from Bio import Seq, SeqIO, SeqRecord, Align
from Bio.Data import IUPACData
from Bio.PDB import PDBParser, MMCIF2Dict
import numpy as np
import pandas as pd


#############################################################
### Load coordinates from PDB file


### Read 3-letter code in title case
def parse_3letter(x):
    &#34;&#34;&#34;Convert 3-letter amino acid code to a single-letter&#34;&#34;&#34;
    return IUPACData.protein_letters_3to1.get(x[0].upper() + x[1:].lower(), &#39;X&#39;)


def parse_pdb_coordinates(path, chain=&#39;&#39;, model=0, all_atom=False):
    &#34;&#34;&#34;Parse coordinates, residue indices, sequence, and bfactor/plddt from a PDB file&#34;&#34;&#34;
    parser = PDBParser(QUIET=True)
    chains = list(parser.get_structure(&#39;&#39;, path)[model])
    coord, idx, seq, bfac = [], [], [], []

    for ch in chains:
        if (ch.get_id() == chain) or (chain == &#39;&#39;):
            for residue in ch:
                try:
                    h, i, _ = residue.get_id()
                    # Ignore HETATM entries
                    if h.strip() != &#39;&#39;:
                        continue
                    aa = residue.resname
                    if all_atom:
                        for atom in residue:
                            coord.append(atom.coord)
                            idx.append(i)
                            seq.append(parse_3letter(aa))
                            bfac.append(atom.bfactor)
                    else:
                        if &#39;CA&#39; not in residue:
                            continue
                        ca = residue[&#39;CA&#39;].coord
                        coord.append(ca)
                        idx.append(i)
                        seq.append(parse_3letter(aa))
                        bfac.append(residue[&#39;CA&#39;].bfactor)
                except Exception as e:
                    print(f&#34;{path}\n{e}&#34;)
                    continue
    return [np.array(x) for x in [coord, idx, seq, bfac]]




#############################################################
### Load coordinates from mmCIF file


def parse_mmcif_coordinates(path, chain=&#39;&#39;):
    &#34;&#34;&#34;Parse coordinates, residue indices, sequence, and bfactor/plddt from a mmCIF file&#34;&#34;&#34;
    mmcif = reformat_mmcif_dict(MMCIF2Dict.MMCIF2Dict(path))
    df = pd.DataFrame(data=mmcif[&#39;_atom_site&#39;])

    # Extract CA atoms
    # model &#39;1&#39;
    # ignore entires with incorrect sequence IDs
    # if there are multiple configurations, only choose &#39;A&#39;
    df = df.loc[(df.label_atom_id==&#39;CA&#39;)&amp;(df.pdbx_PDB_model_num==&#39;1&#39;)&amp;(df.label_seq_id!=&#39;.&#39;)&amp;(df.label_alt_id!=&#39;B&#39;)]

    # Extract specific CHAIN if arg is provided
    if len(chain):
        df = df.loc[(df.label_asym_id==chain)]

    coord = np.array([df[x].values for x in [&#39;Cartn_x&#39;, &#39;Cartn_y&#39;, &#39;Cartn_z&#39;]]).T.astype(float)
    idx = df[&#39;label_seq_id&#39;].values.astype(int)
    seq = np.array([parse_3letter(aa) for aa in df.label_comp_id])
    bfac = df[&#34;B_iso_or_equiv&#34;].values.astype(float)
    return [coord, idx, seq, bfac]


def reformat_mmcif_dict(mmcif):
    &#34;&#34;&#34;Reformat mmCIF dictionary to a nested dictionary&#34;&#34;&#34;
    new_dict = defaultdict(dict)
    for k, v in mmcif.items():
        if &#39;.&#39; not in k:
            new_dict[k] = v 
            continue
        k1 = k.split(&#39;.&#39;)[0]
        k2 = &#39;.&#39;.join(k.split(&#39;.&#39;)[1:])
        new_dict[k1][k2] = v 
    return new_dict



#############################################################
### Load SEQRES 

def load_pdb_seqres(path, chain=&#39;&#39;):
    &#34;&#34;&#34;Load SEQRES sequence from PDB file&#34;&#34;&#34;
    for record in SeqIO.parse(path, &#34;pdb-seqres&#34;):
        if not len(chain):
            return str(record.seq)
        elif record.annotations[&#39;chain&#39;] == chain:
            return str(record.seq)


def load_mmcif_seqres(path, chain=&#39;&#39;):
    &#34;&#34;&#34;Load SEQRES sequence from mmCIF file&#34;&#34;&#34;
    mmcif = reformat_mmcif_dict(MMCIF2Dict.MMCIF2Dict(path))
    df = pd.DataFrame(data=mmcif[&#39;_pdbx_poly_seq_scheme&#39;])

    # Extract specific CHAIN if arg is provided
    if len(chain):
        df = df.loc[(df.asym_id==chain)]

    seq = np.array([parse_3letter(aa) for aa in df.mon_id])
    return &#39;&#39;.join(seq)


#############################################################
### Load PDB file, reorder indices so they start from zero,
### and fill in missing coordinates / Bfactor with NaN values.


### Load SEQRES sequence, and use that to get a more complete
### description of the protein structure that preserves residues
### that are missing atoms.
### Doesn&#39;t work for some rare weird cases that you get in the PDB:
###     e.g. microheterogeneity??? (multiple amino acids for one site, somehow; eg. 1eis)
def load_and_fix_pdb_data(path, chain=&#39;&#39;):
    &#34;&#34;&#34;
    Read PDB / mmCIF file

    Load the SEQRES sequence, and match the atomic coordinates to
    indices based on the SEQRES sequence.
    &#34;&#34;&#34;
    ext = Path(path).suffix

    # Load the sequence from the SEQRES part
    # Load the coords, sequence, etc., from the ATOM part
    if ext in [&#39;.pdb&#39;, &#39;.ent&#39;]:
        seqres = load_pdb_seqres(path, chain)
        xyz, idx, seq, bfac = parse_pdb_coordinates(path, chain)

    elif ext == &#39;.cif&#39;:
        seqres = load_mmcif_seqres(path, chain)
        xyz, idx, seq, bfac = parse_mmcif_coordinates(path, chain)

    # If the ATOM sequence is longer than the SEQRES sequence,
    # then there is a problem
    if len(seqres) &lt; len(seq):
        raise Exception(&#34;ERROR: the number of alpha-carbons exceeds the number of SEQRES residues!&#34; + \
                        &#34;\n\tPlease check your input files for errors.&#34;)

    # If there are no missing atoms, the two sequences will be equal.
    # In this case, the indices will be an integer series starting at 0
    if seqres == &#39;&#39;.join(seq):
        idx = np.arange(len(seq))
    else:
        # If there are missing atoms, try to align the SEQRES / ATOM sequences
        # to get the correct indices
        is_clear, idx = match_xyz_indices_to_seqres(seqres, xyz, seq)
        # If not &#34;is_clear&#34; (if any atom positions are ambiguous),
        # ignore ambiguous atoms
        if not is_clear:
            if len(idx):
                xyz, seq, bfac = [x[idx] for x in [xyz, seq, bfac]]
            else:
                raise Exception(f&#34;Error reading pdb file\n\t{path}&#34;)

    # Fill in missing coordinates with nan values
    xyz_nan = np.zeros((len(seqres), 3), float) * np.nan
    xyz_nan[idx] = xyz 

    return [np.array(x) for x in [xyz, idx, list(seqres), bfac, xyz_nan]]


### Match SEQRES sequence to the sequence obtained from 
### the atomic coordinates. Do NOT allow any mismatches, only gaps.
def match_xyz_indices_to_seqres(seqres, xyz, seq):
    &#34;&#34;&#34;Match the SEQRES sequence to the sequence obtained from ATOM entries&#34;&#34;&#34;
    # Find all residues that are connected along the backbone,
    # and cluster them into unbroken stretches of amino acids
    seq_clusters = find_neighbours(seq, xyz)
    # Run a strict alignment algorithm that discards candidate alignments
    # if they do not agree provide the same set of unbroken sequences
    # of amino acids (sequence clusters)
    candidates = align_sequences(seqres, &#39;&#39;.join(seq), seq_clusters)
    if len(candidates) &gt; 1:
        # If there is more than one alignment, return a single index
        # that corresponds to the positions in the first alignment.
        return False, resolve_ambiguity(candidates)

    elif len(candidates) == 1:
        # If there is only one candidate...
        return True, np.where(np.array(list(candidates[0])) != &#39;-&#39;)[0]

    else:
        # If there are no candidates identified with the strict alignment algorithm,
        # run without enforcing equivalence of sequence clusters
        candidates = align_sequences(seqres, &#39;&#39;.join(seq))
        if len(candidates) &gt; 1:
            return False, resolve_ambiguity(candidates)

        elif len(candidates) == 1:
            return True, np.where(np.array(list(candidates[0])) != &#39;-&#39;)[0]

        else:
            # If there are still no candidates, return False
            return False, []


### Distance between alpha-carbons in neighbouring
### amino acids ought to be about 3.8 AA.
### Cutoff is higher than this, due to inaccuracies in the PDB.
### See &#34;12ca&#34;, positions 125-127 as an example
### Occasionally, this method fails because a string of disordered residues
### are missing, yet the amino acids bookending the missing residues are indexed beside
### each other; not actually that rare (e.g., 4s34_A)
def find_neighbours(seq, xyz, cut=4.3):
    &#34;&#34;&#34;Find backbone neighbors based on their Alpha-carbon distances&#34;&#34;&#34;
    D = np.linalg.norm(xyz[:-1] - xyz[1:], axis=1)
    seq_clusters = []
    cluster = seq[0]
    for s, d in zip(seq[1:], D):
        if d &lt; cut:
            cluster = cluster + s
        else:
            seq_clusters.append(cluster)
            cluster = s
    seq_clusters.append(cluster)
    return seq_clusters


def align_sequences(seqres, seq, seq_clusters=&#39;&#39;):
    &#34;&#34;&#34;Align SEQRES sequences to ATOM sequences&#34;&#34;&#34;
    candidates = []

    # Convert sequence clusters to set
    if not isinstance(seq_clusters, str):
        seqA = set(seq_clusters)

    # Loop through candidate alignments
    aligner = Align.PairwiseAligner()
    aligner.mode = &#39;global&#39;
    # Set mismatch penalty to negative infinity,
    # since no mismatches are not allowed
    aligner.mismatch_score = -np.inf
    for align in aligner.align(seqres, seq):
        s1, s2 = align.sequences
        # If sequence clusters are provided, only allow candidates that
        # include all sequence clusters as unbroken sequences
        if not isinstance(seq_clusters, str):
            # Break alignment into sequence clusters by splitting
            # at gaps
            clusters = [c for c in s2.split(&#39;-&#39;) if len(c)]
            # If all of the previously identified sequence clusters
            # are found in the alignment, add the candidate to the output
            if seqA.issubset(set(clusters)):
                candidates.append(s2)
        else:
            candidates.append(s2)
    return candidates


### Discard any ambiguous residues.
# If there are ambiguous regions, they will be
# as long as the number of candidates, so we can
# account for the indices
# These cases are rare: the algorithm is only called for 3 PDB entries out of ~4000.
def resolve_ambiguity(cand):
    &#34;&#34;&#34;Resolve ambiguous cases where there is more than one alignment between SEQRES and ATOM sequences&#34;&#34;&#34;
    cand = np.array([list(x) for x in cand])
    N = len(cand)
    idx = []
    icount = -1
    # Loop through sequence positions (including gaps)
    for i in range(cand.shape[1]):
        # If no gaps, there is no ambiguity; count the index
        if &#39;-&#39; not in cand[:,i]:
            icount += 1
            idx.append(icount)
        # If there are gaps, ignore the index if there is a gap
        # in the first candidate alignment
        else:
            if cand[0,i] != &#39;-&#39;:
                icount += 1
#               idx.append(icount)
    return np.array(idx)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="PDAnalysis.pdb_parser.align_sequences"><code class="name flex">
<span>def <span class="ident">align_sequences</span></span>(<span>seqres, seq, seq_clusters='')</span>
</code></dt>
<dd>
<div class="desc"><p>Align SEQRES sequences to ATOM sequences</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_sequences(seqres, seq, seq_clusters=&#39;&#39;):
    &#34;&#34;&#34;Align SEQRES sequences to ATOM sequences&#34;&#34;&#34;
    candidates = []

    # Convert sequence clusters to set
    if not isinstance(seq_clusters, str):
        seqA = set(seq_clusters)

    # Loop through candidate alignments
    aligner = Align.PairwiseAligner()
    aligner.mode = &#39;global&#39;
    # Set mismatch penalty to negative infinity,
    # since no mismatches are not allowed
    aligner.mismatch_score = -np.inf
    for align in aligner.align(seqres, seq):
        s1, s2 = align.sequences
        # If sequence clusters are provided, only allow candidates that
        # include all sequence clusters as unbroken sequences
        if not isinstance(seq_clusters, str):
            # Break alignment into sequence clusters by splitting
            # at gaps
            clusters = [c for c in s2.split(&#39;-&#39;) if len(c)]
            # If all of the previously identified sequence clusters
            # are found in the alignment, add the candidate to the output
            if seqA.issubset(set(clusters)):
                candidates.append(s2)
        else:
            candidates.append(s2)
    return candidates</code></pre>
</details>
</dd>
<dt id="PDAnalysis.pdb_parser.find_neighbours"><code class="name flex">
<span>def <span class="ident">find_neighbours</span></span>(<span>seq, xyz, cut=4.3)</span>
</code></dt>
<dd>
<div class="desc"><p>Find backbone neighbors based on their Alpha-carbon distances</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_neighbours(seq, xyz, cut=4.3):
    &#34;&#34;&#34;Find backbone neighbors based on their Alpha-carbon distances&#34;&#34;&#34;
    D = np.linalg.norm(xyz[:-1] - xyz[1:], axis=1)
    seq_clusters = []
    cluster = seq[0]
    for s, d in zip(seq[1:], D):
        if d &lt; cut:
            cluster = cluster + s
        else:
            seq_clusters.append(cluster)
            cluster = s
    seq_clusters.append(cluster)
    return seq_clusters</code></pre>
</details>
</dd>
<dt id="PDAnalysis.pdb_parser.load_and_fix_pdb_data"><code class="name flex">
<span>def <span class="ident">load_and_fix_pdb_data</span></span>(<span>path, chain='')</span>
</code></dt>
<dd>
<div class="desc"><p>Read PDB / mmCIF file</p>
<p>Load the SEQRES sequence, and match the atomic coordinates to
indices based on the SEQRES sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_and_fix_pdb_data(path, chain=&#39;&#39;):
    &#34;&#34;&#34;
    Read PDB / mmCIF file

    Load the SEQRES sequence, and match the atomic coordinates to
    indices based on the SEQRES sequence.
    &#34;&#34;&#34;
    ext = Path(path).suffix

    # Load the sequence from the SEQRES part
    # Load the coords, sequence, etc., from the ATOM part
    if ext in [&#39;.pdb&#39;, &#39;.ent&#39;]:
        seqres = load_pdb_seqres(path, chain)
        xyz, idx, seq, bfac = parse_pdb_coordinates(path, chain)

    elif ext == &#39;.cif&#39;:
        seqres = load_mmcif_seqres(path, chain)
        xyz, idx, seq, bfac = parse_mmcif_coordinates(path, chain)

    # If the ATOM sequence is longer than the SEQRES sequence,
    # then there is a problem
    if len(seqres) &lt; len(seq):
        raise Exception(&#34;ERROR: the number of alpha-carbons exceeds the number of SEQRES residues!&#34; + \
                        &#34;\n\tPlease check your input files for errors.&#34;)

    # If there are no missing atoms, the two sequences will be equal.
    # In this case, the indices will be an integer series starting at 0
    if seqres == &#39;&#39;.join(seq):
        idx = np.arange(len(seq))
    else:
        # If there are missing atoms, try to align the SEQRES / ATOM sequences
        # to get the correct indices
        is_clear, idx = match_xyz_indices_to_seqres(seqres, xyz, seq)
        # If not &#34;is_clear&#34; (if any atom positions are ambiguous),
        # ignore ambiguous atoms
        if not is_clear:
            if len(idx):
                xyz, seq, bfac = [x[idx] for x in [xyz, seq, bfac]]
            else:
                raise Exception(f&#34;Error reading pdb file\n\t{path}&#34;)

    # Fill in missing coordinates with nan values
    xyz_nan = np.zeros((len(seqres), 3), float) * np.nan
    xyz_nan[idx] = xyz 

    return [np.array(x) for x in [xyz, idx, list(seqres), bfac, xyz_nan]]</code></pre>
</details>
</dd>
<dt id="PDAnalysis.pdb_parser.load_mmcif_seqres"><code class="name flex">
<span>def <span class="ident">load_mmcif_seqres</span></span>(<span>path, chain='')</span>
</code></dt>
<dd>
<div class="desc"><p>Load SEQRES sequence from mmCIF file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_mmcif_seqres(path, chain=&#39;&#39;):
    &#34;&#34;&#34;Load SEQRES sequence from mmCIF file&#34;&#34;&#34;
    mmcif = reformat_mmcif_dict(MMCIF2Dict.MMCIF2Dict(path))
    df = pd.DataFrame(data=mmcif[&#39;_pdbx_poly_seq_scheme&#39;])

    # Extract specific CHAIN if arg is provided
    if len(chain):
        df = df.loc[(df.asym_id==chain)]

    seq = np.array([parse_3letter(aa) for aa in df.mon_id])
    return &#39;&#39;.join(seq)</code></pre>
</details>
</dd>
<dt id="PDAnalysis.pdb_parser.load_pdb_seqres"><code class="name flex">
<span>def <span class="ident">load_pdb_seqres</span></span>(<span>path, chain='')</span>
</code></dt>
<dd>
<div class="desc"><p>Load SEQRES sequence from PDB file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_pdb_seqres(path, chain=&#39;&#39;):
    &#34;&#34;&#34;Load SEQRES sequence from PDB file&#34;&#34;&#34;
    for record in SeqIO.parse(path, &#34;pdb-seqres&#34;):
        if not len(chain):
            return str(record.seq)
        elif record.annotations[&#39;chain&#39;] == chain:
            return str(record.seq)</code></pre>
</details>
</dd>
<dt id="PDAnalysis.pdb_parser.match_xyz_indices_to_seqres"><code class="name flex">
<span>def <span class="ident">match_xyz_indices_to_seqres</span></span>(<span>seqres, xyz, seq)</span>
</code></dt>
<dd>
<div class="desc"><p>Match the SEQRES sequence to the sequence obtained from ATOM entries</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_xyz_indices_to_seqres(seqres, xyz, seq):
    &#34;&#34;&#34;Match the SEQRES sequence to the sequence obtained from ATOM entries&#34;&#34;&#34;
    # Find all residues that are connected along the backbone,
    # and cluster them into unbroken stretches of amino acids
    seq_clusters = find_neighbours(seq, xyz)
    # Run a strict alignment algorithm that discards candidate alignments
    # if they do not agree provide the same set of unbroken sequences
    # of amino acids (sequence clusters)
    candidates = align_sequences(seqres, &#39;&#39;.join(seq), seq_clusters)
    if len(candidates) &gt; 1:
        # If there is more than one alignment, return a single index
        # that corresponds to the positions in the first alignment.
        return False, resolve_ambiguity(candidates)

    elif len(candidates) == 1:
        # If there is only one candidate...
        return True, np.where(np.array(list(candidates[0])) != &#39;-&#39;)[0]

    else:
        # If there are no candidates identified with the strict alignment algorithm,
        # run without enforcing equivalence of sequence clusters
        candidates = align_sequences(seqres, &#39;&#39;.join(seq))
        if len(candidates) &gt; 1:
            return False, resolve_ambiguity(candidates)

        elif len(candidates) == 1:
            return True, np.where(np.array(list(candidates[0])) != &#39;-&#39;)[0]

        else:
            # If there are still no candidates, return False
            return False, []</code></pre>
</details>
</dd>
<dt id="PDAnalysis.pdb_parser.parse_3letter"><code class="name flex">
<span>def <span class="ident">parse_3letter</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert 3-letter amino acid code to a single-letter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_3letter(x):
    &#34;&#34;&#34;Convert 3-letter amino acid code to a single-letter&#34;&#34;&#34;
    return IUPACData.protein_letters_3to1.get(x[0].upper() + x[1:].lower(), &#39;X&#39;)</code></pre>
</details>
</dd>
<dt id="PDAnalysis.pdb_parser.parse_mmcif_coordinates"><code class="name flex">
<span>def <span class="ident">parse_mmcif_coordinates</span></span>(<span>path, chain='')</span>
</code></dt>
<dd>
<div class="desc"><p>Parse coordinates, residue indices, sequence, and bfactor/plddt from a mmCIF file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_mmcif_coordinates(path, chain=&#39;&#39;):
    &#34;&#34;&#34;Parse coordinates, residue indices, sequence, and bfactor/plddt from a mmCIF file&#34;&#34;&#34;
    mmcif = reformat_mmcif_dict(MMCIF2Dict.MMCIF2Dict(path))
    df = pd.DataFrame(data=mmcif[&#39;_atom_site&#39;])

    # Extract CA atoms
    # model &#39;1&#39;
    # ignore entires with incorrect sequence IDs
    # if there are multiple configurations, only choose &#39;A&#39;
    df = df.loc[(df.label_atom_id==&#39;CA&#39;)&amp;(df.pdbx_PDB_model_num==&#39;1&#39;)&amp;(df.label_seq_id!=&#39;.&#39;)&amp;(df.label_alt_id!=&#39;B&#39;)]

    # Extract specific CHAIN if arg is provided
    if len(chain):
        df = df.loc[(df.label_asym_id==chain)]

    coord = np.array([df[x].values for x in [&#39;Cartn_x&#39;, &#39;Cartn_y&#39;, &#39;Cartn_z&#39;]]).T.astype(float)
    idx = df[&#39;label_seq_id&#39;].values.astype(int)
    seq = np.array([parse_3letter(aa) for aa in df.label_comp_id])
    bfac = df[&#34;B_iso_or_equiv&#34;].values.astype(float)
    return [coord, idx, seq, bfac]</code></pre>
</details>
</dd>
<dt id="PDAnalysis.pdb_parser.parse_pdb_coordinates"><code class="name flex">
<span>def <span class="ident">parse_pdb_coordinates</span></span>(<span>path, chain='', model=0, all_atom=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse coordinates, residue indices, sequence, and bfactor/plddt from a PDB file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_pdb_coordinates(path, chain=&#39;&#39;, model=0, all_atom=False):
    &#34;&#34;&#34;Parse coordinates, residue indices, sequence, and bfactor/plddt from a PDB file&#34;&#34;&#34;
    parser = PDBParser(QUIET=True)
    chains = list(parser.get_structure(&#39;&#39;, path)[model])
    coord, idx, seq, bfac = [], [], [], []

    for ch in chains:
        if (ch.get_id() == chain) or (chain == &#39;&#39;):
            for residue in ch:
                try:
                    h, i, _ = residue.get_id()
                    # Ignore HETATM entries
                    if h.strip() != &#39;&#39;:
                        continue
                    aa = residue.resname
                    if all_atom:
                        for atom in residue:
                            coord.append(atom.coord)
                            idx.append(i)
                            seq.append(parse_3letter(aa))
                            bfac.append(atom.bfactor)
                    else:
                        if &#39;CA&#39; not in residue:
                            continue
                        ca = residue[&#39;CA&#39;].coord
                        coord.append(ca)
                        idx.append(i)
                        seq.append(parse_3letter(aa))
                        bfac.append(residue[&#39;CA&#39;].bfactor)
                except Exception as e:
                    print(f&#34;{path}\n{e}&#34;)
                    continue
    return [np.array(x) for x in [coord, idx, seq, bfac]]</code></pre>
</details>
</dd>
<dt id="PDAnalysis.pdb_parser.reformat_mmcif_dict"><code class="name flex">
<span>def <span class="ident">reformat_mmcif_dict</span></span>(<span>mmcif)</span>
</code></dt>
<dd>
<div class="desc"><p>Reformat mmCIF dictionary to a nested dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reformat_mmcif_dict(mmcif):
    &#34;&#34;&#34;Reformat mmCIF dictionary to a nested dictionary&#34;&#34;&#34;
    new_dict = defaultdict(dict)
    for k, v in mmcif.items():
        if &#39;.&#39; not in k:
            new_dict[k] = v 
            continue
        k1 = k.split(&#39;.&#39;)[0]
        k2 = &#39;.&#39;.join(k.split(&#39;.&#39;)[1:])
        new_dict[k1][k2] = v 
    return new_dict</code></pre>
</details>
</dd>
<dt id="PDAnalysis.pdb_parser.resolve_ambiguity"><code class="name flex">
<span>def <span class="ident">resolve_ambiguity</span></span>(<span>cand)</span>
</code></dt>
<dd>
<div class="desc"><p>Resolve ambiguous cases where there is more than one alignment between SEQRES and ATOM sequences</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_ambiguity(cand):
    &#34;&#34;&#34;Resolve ambiguous cases where there is more than one alignment between SEQRES and ATOM sequences&#34;&#34;&#34;
    cand = np.array([list(x) for x in cand])
    N = len(cand)
    idx = []
    icount = -1
    # Loop through sequence positions (including gaps)
    for i in range(cand.shape[1]):
        # If no gaps, there is no ambiguity; count the index
        if &#39;-&#39; not in cand[:,i]:
            icount += 1
            idx.append(icount)
        # If there are gaps, ignore the index if there is a gap
        # in the first candidate alignment
        else:
            if cand[0,i] != &#39;-&#39;:
                icount += 1
#               idx.append(icount)
    return np.array(idx)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PDAnalysis" href="index.html">PDAnalysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="PDAnalysis.pdb_parser.align_sequences" href="#PDAnalysis.pdb_parser.align_sequences">align_sequences</a></code></li>
<li><code><a title="PDAnalysis.pdb_parser.find_neighbours" href="#PDAnalysis.pdb_parser.find_neighbours">find_neighbours</a></code></li>
<li><code><a title="PDAnalysis.pdb_parser.load_and_fix_pdb_data" href="#PDAnalysis.pdb_parser.load_and_fix_pdb_data">load_and_fix_pdb_data</a></code></li>
<li><code><a title="PDAnalysis.pdb_parser.load_mmcif_seqres" href="#PDAnalysis.pdb_parser.load_mmcif_seqres">load_mmcif_seqres</a></code></li>
<li><code><a title="PDAnalysis.pdb_parser.load_pdb_seqres" href="#PDAnalysis.pdb_parser.load_pdb_seqres">load_pdb_seqres</a></code></li>
<li><code><a title="PDAnalysis.pdb_parser.match_xyz_indices_to_seqres" href="#PDAnalysis.pdb_parser.match_xyz_indices_to_seqres">match_xyz_indices_to_seqres</a></code></li>
<li><code><a title="PDAnalysis.pdb_parser.parse_3letter" href="#PDAnalysis.pdb_parser.parse_3letter">parse_3letter</a></code></li>
<li><code><a title="PDAnalysis.pdb_parser.parse_mmcif_coordinates" href="#PDAnalysis.pdb_parser.parse_mmcif_coordinates">parse_mmcif_coordinates</a></code></li>
<li><code><a title="PDAnalysis.pdb_parser.parse_pdb_coordinates" href="#PDAnalysis.pdb_parser.parse_pdb_coordinates">parse_pdb_coordinates</a></code></li>
<li><code><a title="PDAnalysis.pdb_parser.reformat_mmcif_dict" href="#PDAnalysis.pdb_parser.reformat_mmcif_dict">reformat_mmcif_dict</a></code></li>
<li><code><a title="PDAnalysis.pdb_parser.resolve_ambiguity" href="#PDAnalysis.pdb_parser.resolve_ambiguity">resolve_ambiguity</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>